---
phase: 09-update-notification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - electron/main.ts
  - electron/preload.ts
  - src/types/electron.d.ts
  - src/lib/version.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "App version is accessible from renderer process"
    - "External URLs can be opened via Electron shell"
    - "Semantic version comparison works correctly (1.9.0 < 1.10.0)"
  artifacts:
    - path: "electron/main.ts"
      provides: "IPC handlers for version and openExternal"
      contains: "ipcMain.handle"
    - path: "electron/preload.ts"
      provides: "IPC invoke calls exposed to renderer"
      contains: "ipcRenderer.invoke"
    - path: "src/types/electron.d.ts"
      provides: "TypeScript declarations for window.electronAPI"
      contains: "interface Window"
    - path: "src/lib/version.ts"
      provides: "Semantic version comparison utility"
      exports: ["isNewerVersion"]
  key_links:
    - from: "electron/preload.ts"
      to: "electron/main.ts"
      via: "ipcRenderer.invoke -> ipcMain.handle"
      pattern: "app:get-version|shell:open-external"
---

<objective>
Extend Electron IPC to expose app version and external URL opening to the renderer process, and add semantic version comparison utility.

Purpose: Enable the update check UI (Plan 02) to read the current app version and open the GitHub releases page in the user's browser.

Output: IPC handlers in main process, contextBridge exposure in preload, TypeScript declarations, and version comparison utility using semver library.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-update-notification/09-CONTEXT.md
@.planning/phases/09-update-notification/09-RESEARCH.md
@electron/main.ts
@electron/preload.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IPC handlers in main process</name>
  <files>electron/main.ts</files>
  <action>
Add IPC handlers at the top of electron/main.ts (after imports):

1. Import `ipcMain` and `shell` from electron (add to existing import)
2. Add two IPC handlers:

```typescript
// IPC handlers for update notification
ipcMain.handle('app:get-version', () => app.getVersion());

ipcMain.handle('shell:open-external', (_event, url: string) => {
  // Security: Only allow GitHub URLs for this app
  if (url.startsWith('https://github.com/kai-osthoff/sporttag')) {
    return shell.openExternal(url);
  }
  throw new Error('Invalid URL - only GitHub sporttag URLs allowed');
});
```

Place these handlers BEFORE the `waitForServer` function (after imports, before any function definitions). This ensures they are registered when the app starts.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit -p electron/tsconfig.json`</verify>
  <done>electron/main.ts has ipcMain.handle for 'app:get-version' and 'shell:open-external'</done>
</task>

<task type="auto">
  <name>Task 2: Extend preload and add TypeScript declarations</name>
  <files>electron/preload.ts, src/types/electron.d.ts</files>
  <action>
1. Update electron/preload.ts to add IPC invoke calls:

```typescript
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
  isElectron: true,
  getVersion: () => ipcRenderer.invoke('app:get-version'),
  openExternal: (url: string) => ipcRenderer.invoke('shell:open-external', url),
});
```

2. Create src/types/electron.d.ts with TypeScript declarations:

```typescript
declare global {
  interface Window {
    electronAPI?: {
      isElectron: boolean;
      getVersion: () => Promise<string>;
      openExternal: (url: string) => Promise<void>;
    };
  }
}

export {};
```

The `export {}` is required to make this a module (ambient declaration in global scope).
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>preload.ts exposes getVersion and openExternal; TypeScript recognizes window.electronAPI type</done>
</task>

<task type="auto">
  <name>Task 3: Install semver and create version utility</name>
  <files>package.json, src/lib/version.ts</files>
  <action>
1. Install semver package:
```bash
npm install semver
npm install -D @types/semver
```

2. Create src/lib/version.ts:

```typescript
import { gt, coerce } from 'semver';

/**
 * Compare two version strings using semantic versioning.
 * Handles "v" prefix (e.g., "v1.2.3" from GitHub tags).
 *
 * @param latestTag - The latest version tag (may have "v" prefix)
 * @param currentVersion - The current app version (from package.json)
 * @returns true if latestTag is newer than currentVersion
 */
export function isNewerVersion(latestTag: string, currentVersion: string): boolean {
  // coerce handles "v" prefix and partial versions
  const latest = coerce(latestTag);
  const current = coerce(currentVersion);

  if (!latest || !current) {
    return false; // Can't compare invalid versions
  }

  return gt(latest, current);
}
```

This utility uses semver.coerce() to handle the "v" prefix that GitHub tags typically have (e.g., "v2.1.0"), and semver.gt() for proper semantic comparison (avoiding issues like "1.9.0" > "1.10.0" with string comparison).
  </action>
  <verify>
1. `npm ls semver` shows semver installed
2. TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>semver package installed; src/lib/version.ts exports isNewerVersion function</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run lint` passes (no ESLint errors)
2. `npx tsc --noEmit` compiles without errors
3. Manual test: `npm run electron:dev`, then in renderer console: `window.electronAPI.getVersion()` returns "2.0.0"
</verification>

<success_criteria>
- IPC handlers registered in main.ts for version and openExternal
- preload.ts exposes both functions via contextBridge
- TypeScript declarations allow type-safe access to window.electronAPI
- semver installed and version comparison utility created
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-update-notification/09-01-SUMMARY.md`
</output>
